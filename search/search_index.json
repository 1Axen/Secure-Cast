{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Secure-Cast","text":"<p>A server-authoritative projectile system for ROBLOX. </p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>SecureCast is aimed at providing an easy solution to server authoritative projectile using the ROBLOX humanoid system. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Good performance</li> <li>Simple and powerful API</li> <li>Synced Server-Client simulation</li> <li>Multi-threading / Parallel LuaU support</li> <li>Lag compensated hitboxes on the server</li> <li>Bullet drop, grenades bouncing, ricochets, wall penetration</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Head over to the installation page to get started with SecureCast.</p>"},{"location":"#license","title":"License","text":"<p>SecureCast is licensed under the MIT License.</p>"},{"location":"API/definitions/","title":"Definitions","text":""},{"location":"API/definitions/#definitions","title":"Definitions","text":"<p>This page contains all types defined and used by SecureCast.</p> <p>type  Modifier ( number Loss,      number Power,      number Angle,      number Gravity,      number Velocity,      number Lifetime,      BindableEvent? OnImpact,      BindableEvent? OnDestroyed,      BindableEvent? OnIntersection,      RaycastParams? RaycastFilter,      {[string]: any}? Extra, )</p> <p>Modifiers are a powerful tool that allows you to define per cast functionality seperate from the base projectile definition.</p> Custom event handling<pre><code>local Bindable = Instance.new(\"BindableEvent\")\nBindable.Event:Connect(function(Type: string, Event: string, ...)\n    if Event == \"OnDestroyed\" then\n        --&gt; No need to keep a reference to the connection \n        --&gt; since destroy will take care of it for us\n        Bindable:Destroy()\n    elseif Event == \"OnImpact\" then\n\n    elseif Event == \"OnIntersection\" then\n\n    end\nend)\n\nlocal Modifier = {\n    OnImpact = Bindable,\n    OnDestroyed = Bindable,\n    OnIntersection = Bindable,\n}\n\nSecureCast.Cast(Player, \"Bullet\", Origin, Direction, Time, nil, Modifier)\n</code></pre> <p>Danger</p> <p>When using Modifiers make sure that all clients and the server use the same modifier, improper modifier usage can result in simulation desync.</p> <p>type  Definition ( number Loss,      number Power,      number Angle,      number Gravity,      number Velocity,      number Lifetime,      BindableEvent? Output,      RaycastParams? RaycastFilter,      void OnImpact (          Player Caster,          Vector3 Direction,          Instance Instance,          Vector3 Normal,          Vector3 Position,          Enum.Material Material {[string]: any}? Extra,     \u2003),      void OnDestroyed (          Player Caster,          Vector3 Position {[string]: any}? Extra,     \u2003),      void OnIntersection (          Player Caster,          Vector3 Direction,          string Part,          Player? Victim,          Vector3 Position Model? VictimCharacter,          {[string]: any}? Extra,     \u2003), )</p> <p>This type represents the way that projectiles should be defined within the system. Refer to the template bullet included within the GitHub repository for an example.</p> <p>type  Record ( {CFrame} Parts,      Vector3 Position, )</p> <p>type  Snapshot ( number Time,      Voxels.Grid Grid,      {[Player]: Record} Records, )</p>"},{"location":"API/securecast/","title":"SecureCast","text":""},{"location":"API/securecast/#securecast","title":"SecureCast","text":"<p>SecureCast is the top-level interface for interacting with the system. It is returned by <code>require(SecureCast)</code>.</p>"},{"location":"API/securecast/#members","title":"Members","text":"<p>Utility  Snapshots</p> <p>The snapshots utility used by the simulation, you can use this to retrieve player positions back in time for lag compensation. The API for this utility is available here.  </p> <p>Warning</p> <p>Snapshots can only be used on the server, calling any of the methods within the utility will throw an error when called from the client!</p>"},{"location":"API/securecast/#methods","title":"Methods","text":"<p>void  Initialize ( )</p> <p>Initialize the simulation for the current context.</p> <p>Warning</p> <p>Initialize can only be called once per context, subsequent calls will result in an error.</p> <p>void  Cast ( Player Caster,      string Type,      Vector3 Origin Vector3 Direction number Timestamp PVInstance? PVInstance Modifier? Modifier )</p> <p>Casts a new projectile. A Modifier can be used to modify the behaviour of a projectile on a per cast basis. A PVInstance must exist on the client in order for the projectile to be rendered.</p> <p>Danger</p> <p>When using a Modifier make sure that all clients and the server use the same modifier, improper modifier usage can result in simulation desync.</p>"},{"location":"API/settings/","title":"Settings","text":""},{"location":"API/settings/#settings","title":"Settings","text":"<p>This page contains all settings used by SecureCast. These can be found in the Settings module under the SecureCast module.</p> <p>number  VoxelSize</p> <p>The size of each voxel in studs.</p> <p>Vector3  VoxelGridSize</p> <p>The size of the voxel grid in studs.</p> <p>Danger</p> <p>Be careful when editing this value, anything smaller than the playable area will result in players being missed by the server raycasts.</p> <p>number  SnapshotLifetime</p> <p>The lifetime of snapshots in seconds.</p> <p>Danger</p> <p>Be careful when editing this value, very small values will result in players with high ping not being able to land shots but high values may result in players being hit behind cover long after they have gone behind it.</p> <p>Instance  Definitions</p> <p>The container for projectile definitions modules.</p> <p>{[Enum.Material]: number}  SurfaceHardness</p> <p>An array of each materials hardness. The needed penetration power can be calculate with the following formula: <code>Power = SurfaceDepth * SurfaceHardness</code></p> <p>number  RicochetHardness</p> <p>The minimum surface hardness needed for a projectile to ricochet off of something. This is ignored when a projectile has a ricochet angle set to <code>math.pi * 2</code>.</p> <p>{string}  Parts</p> <p>An array containing the names of every hitbox in a players character, ordered from most to least damage.</p> <p>{Vector3}  PartsSizes</p> <p>An array containing the halved sizes of every hitbox in a players character, in the same order as the <code>Parts</code> array.</p> <p>Vector3  HitboxSize</p> <p>The maximum halved size of a players character, it needs to contain the character at it's maximum arm span.</p>"},{"location":"API/snapshots/","title":"Snapshots","text":""},{"location":"API/snapshots/#snapshots","title":"Snapshots","text":"<p>The snapshots utility is used by the simulation to take \"snapshots\" of player positions in the past for lag compensation.</p> <p>Note</p> <p>Times must be retrieved using workspace:GetServerTimeNow()</p>"},{"location":"API/snapshots/#methods","title":"Methods","text":"<p>{[string]: CFrame}?  GetPlayerAtTime ( Player Player number Time )</p> <p>Returns an array containing the CFrame of each of the player's hitboxes in the past, returns nothing when no snapshots containing the player can be found.</p> <p>{[Player]: {[string]: CFrame}}  GetPlayersAtTime ( number Time )</p> <p>Returns an array containing the CFrame of each of the hitboxes of every player in the past.</p> <p>Snapshot?, Snapshot?, number?  GetSnapshotsAtTime ( number Time )</p> <p>Returns a tuple containing the previous snapshot, next snapshot and the fraction used for lerping between them, returns nothing if no snapshots can be found for the given time.</p> <p>void  CreatePlayersSnapshot ( number Time )</p> <p>Creates a snapshot of every players hitbox at the given time.</p> <p>Danger</p> <p>This method should not be called or it may result in undefined behaviour, this is already called by SecureCast internally.</p>"},{"location":"Getting%20Started/Installation/","title":"Installation","text":"<p>Installing the module into your place is simple, we will cover the different methods of installation down below.</p>"},{"location":"Getting%20Started/Installation/#with-wally","title":"With Wally","text":"<p>SecureCast is available as a Wally package. Navigate to your projects <code>wally.toml</code> file and add the following dependancy <pre><code>securecast = \"1axen/secure-cast\"\n</code></pre> After adding SecureCast to your dependencies you will need to install it by running <pre><code>wally install\n</code></pre></p>"},{"location":"Getting%20Started/Installation/#with-git","title":"With git","text":"<p>SecureCast can be directly cloned from GitHub <pre><code>git clone https://github.com/1Axen/Secure-Cast.git\n</code></pre></p> <p>Warning</p> <p>The master branch of the GitHub repository contains the latest development version and may not be stable.</p>"},{"location":"Getting%20Started/Installation/#with-github-releases","title":"With GitHub releases","text":"<p>The latest stable version of the module can be downloaded from https://github.com/1Axen/Secure-Cast/releases After downloading the RBXM file insert it into ReplicatedStorage or any other shared container of your choice.</p>"},{"location":"Getting%20Started/Modifiers/","title":"Modifiers","text":"<p>Modifiers are a powerful tool that allows you to define per cast functionality seperate from the base projectile definition. They can be used to alter already existing projectile definitions for example: Giving a grenade extra velocity for jump/run throws.  </p> <p>Danger</p> <p>When using Modifiers make sure that all clients and the server use the same modifier, improper modifier usage can result in simulation desync.</p>"},{"location":"Getting%20Started/Modifiers/#example","title":"Example","text":"<p>I will be using the simulation setup from the previous page, if you haven't setup your simulaton yet refer to the previous page. In this example we will create a modifier that gives a bullet extra penetrative power, this modifier will be controlled by an attribute \"ExtraPenetration\" in the players character. Example client simulation with modifiers<pre><code>...\n\nUserInputService.InputBegan:Connect(function(Input, GPE)\n    ...\n\n    local ProjectileModifier;\n    if Character:GetAttribute(\"ExtraPenetration\") then\n        ProjectileModifier = {\n            Power = 200\n        }\n    end\n\n    local Time = workspace:GetServerTimeNow()\n\n    --&gt; Replicate to the server\n    SimulateEvent:FireServer(Origin, Direction, Time)\n\n    --&gt; Cast the projectile within our own simulation\n    SecureCast.Cast(Player, \"Bullet\", Origin, Direction, Time, nil, ProjectileModifier)\nend)\n\n...\n</code></pre></p> Example server simulation with modifiers<pre><code>...\n\nReplicatedStorage.Events.Simulate.OnServerEvent:Connect(function(Player: Player, Origin: Vector3, Direction: Vector3, Timestamp: number)\n    ...\n\n    local ProjectileModifier;\n    if Character:GetAttribute(\"ExtraPenetration\") then\n        ProjectileModifier = {\n            Power = 200\n        }\n    end\n\n    --&gt; Replicate the projectile to all other clients\n    SimulateEvent:FireAllClients(Player, \"Bullet\", Origin, Direction, nil, ProjectileModifier)\n\n    --&gt; Cast the projectile within our own simulation\n    SecureCast.Cast(Player, \"Bullet\", Origin, Direction, Time - Latency - Interpolation, nil, ProjectileModifier)\nend)\n</code></pre>"},{"location":"Getting%20Started/Simulation/","title":"Simulation","text":"<p>In this section we will explore setting up a basic simulation along side the different things we must account for in order to create a working simulation.</p>"},{"location":"Getting%20Started/Simulation/#setting-up-your-workspace","title":"Setting up your workspace","text":"<p>SecureCast requires a <code>Map</code> and <code>Characters</code> folder placed within workspace to function correctly. All parts of the map must be a descendant of the <code>Map</code> folder.  All player characters must be paranted to the <code>Characters</code> folder.</p> <p>We will also need an <code>Events</code> folder within ReplicatedStorage. Add a RemoteEvent named <code>Simulation</code> under the <code>Events</code> folder.</p>"},{"location":"Getting%20Started/Simulation/#setting-up-your-client","title":"Setting up your client","text":"<p>Create a LocalScript and place it under StarterPlayerScripts. Copy and paste the following code into the script you just created: Example client simulation<pre><code>--!strict\n\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal UserInputService = game:GetService(\"UserInputService\")\n\nlocal SecureCast = require(ReplicatedStorage.SecureCast)\n\nlocal Player = Players.LocalPlayer\nlocal Mouse = Player:GetMouse()\n\nlocal Events = ReplicatedStorage.Events\nlocal SimulateEvent = Events.Simulate\n\n--&gt; Only call once per context\nSecureCast.Initialize()\n\nUserInputService.InputBegan:Connect(function(Input, GPE)\n    if GPE or Input.UserInputType ~= Enum.UserInputType.MouseButton1 then\n        return\n    end\n\n    local Character = Player.Character\n    local Head = Character and Character:FindFirstChild(\"Head\")\n    if not Head then\n        return\n    end\n\n    local Origin = Head.Position\n    local Direction = (Mouse.Hit.Position - Origin).Unit\n\n    local Time = workspace:GetServerTimeNow()\n\n    --&gt; Replicate to the server\n    SimulateEvent:FireServer(Origin, Direction, Time)\n\n    --&gt; Cast the projectile within our own simulation\n    SecureCast.Cast(Player, \"Bullet\", Origin, Direction, Time)\nend)\n\nSimulateEvent.OnClientEvent:Connect(function(Caster: Player, Type: string, Origin: Vector3, Direction: Vector3, PVInstance: PVInstance?, Modifer)\n    if Caster ~= Player then\n        SecureCast.Cast(Caster, Type, Origin, Direction, workspace:GetServerTimeNow(), PVInstance, Modifer)\n    end\nend)\n</code></pre></p>"},{"location":"Getting%20Started/Simulation/#setting-up-your-server","title":"Setting up your server","text":"<p>Create a Script and place it under ServerScriptService. Copy and paste the following code into the script you just created: Example server simulation<pre><code>--!strict\n\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal RunService = game:GetService(\"RunService\")\n\nlocal SecureCast = require(ReplicatedStorage.SecureCast)\n\nlocal MAXIMUM_LATENCY = 0.8 -- 800 ms\n\nlocal Events = ReplicatedStorage.Events\nlocal SimulateEvent = Events.Simulate\n\n--&gt; Only call once per context\nSecureCast.Initialize()\n\nPlayers.PlayerAdded:Connect(function(Player: Player)\n    --&gt; We must parent all characters to the Characters folder within workspace\n    Player.CharacterAdded:Connect(function(Character)\n        RunService.PostSimulation:Wait()\n        Character.Parent = workspace.Characters\n    end)\n\n    --&gt; Disable raycast interactions with accessories\n    Player.CharacterAppearanceLoaded:Connect(function(Character)\n        for _, Child in Character:GetChildren() do\n            if not Child:IsA(\"Accessory\") then\n                continue\n            end\n\n            local Handle: BasePart? = Child:FindFirstChild(\"Handle\") :: BasePart\n            if Handle then\n                Handle.CanQuery = false\n            end\n        end\n    end)\nend)\n\nReplicatedStorage.Events.Simulate.OnServerEvent:Connect(function(Player: Player, Origin: Vector3, Direction: Vector3, Timestamp: number)\n    --&gt; It is best to have calculate these values at the top\n    --&gt; We can have the most accurate latency values this way\n    --&gt; Calculating them further down may result in skewed results\n\n    --&gt; We must take into account character interpolation\n    --&gt; The best estimate for this value available is (PLAYER_PING + 48 ms)\n    --&gt; If we do not factor in interpolation we will end up with inaccurate lag compensation\n\n    local Latency = (workspace:GetServerTimeNow() - Timestamp)\n    local Interpolation = (Player:GetNetworkPing() + SecureCast.Settings.Interpolation)\n\n    --&gt; Validate the latency and avoid players with very slow connections\n    if (Latency &lt; 0) or (Latency &gt; MAXIMUM_LATENCY) then\n        return\n    end\n\n    --&gt; Validate the projectile origin\n    local Character = Player.Character\n    local Head: BasePart? = Character and Character:FindFirstChild(\"Head\") :: BasePart\n    if not Head then\n        return\n    end\n\n    local Distance = (Origin - Head.Position).Magnitude\n    if Distance &gt; 5 then\n        warn(`{Player} is too far from the projectile origin.`)\n        return\n    end\n\n    --&gt; Replicate the projectile to all other clients\n    SimulateEvent:FireAllClients(Player, \"Bullet\", Origin, Direction)\n\n    --&gt; Cast the projectile within our own simulation\n    SecureCast.Cast(Player, \"Bullet\", Origin, Direction, Timestamp - Interpolation)\nend)\n</code></pre></p>"},{"location":"Getting%20Started/Simulation/#test-your-simulation","title":"Test your simulation","text":"<p>You can test if your simulation is working properly by going into a Local Test Server.</p> <p>Note</p> <p>Make sure to create 2 seperate teams or the players will be ignored due to being on the same team.</p>"}]}